
// Этот класс знает про оптимальную возможность реализации каждого алгоритма.
// К примеру это Generic, SSE...
// И в данном плане различаются не только алгоритмы шифрования блоков (Key) но и алгоритмы обработки потоков.
// AVX512 может обрабатывать в паралель до 64 байт? так чтоль.
// Это значит, что ключ должен быть предназначен для того, чтобы в него можно было загрузить сразу 8 блоков данных.
// Это значит, что для каждого Arch - Свой тип ключа и свои потоковые алгоритмы. И свои узлы замен кстати тоже.
//
// При этом я еще не хочу, чтобы у меня тут возникал большой список методов.
// Вероятно мне нужны какие-то коды алгоритмов, чтобы выбрать правильный враппер.
// А иногда это еще связано и с дополнительными данными, типа вектора инициализации.
// И получается константа нам не сильно поможет. Должен быть класс.
// Причем класс независимый от архитектуры.
// Через него можно делать двойную диспетчеризацию пожалуй.
//
// А куда передаем ключ? В конструктор Arch? То есть на каждый ключ свой Arch?
// Это кстати в какой-то мере разумно. Часто из одного ключа делают несколько разных вещей.
// Зашифровать, посчитать имитовставку.
//
//	Вот мы в коде как пишем?
//	const auto sink = ECBAlg(make_shared<SSEFactory>(sse_key)).sink();
//
//	Либо мы пишем
//	const auto sink = SSEFactory(key).sink(parent_sink, make_shared<ECBAlg>());
//
// ECBAlg {
// 	EcbAlg(); << No imput parameters
// 	shared_ptr<const Sink> sink(const shared_ptr(),  const shared_ptr<const ArchFactory> &factory) const {
// 		return factory->ecb_sink(
// 	} 
// }
//
// То есть у меня есть три измерения...
// Архитектура.
// Алгоритм
// Направление потока (Sink/Source)
//
// Какой из них самый важный?
// Архитектура с ключем может быть более долгоживущая, но ее можно и в качестве параметра передавать.
//
// const auto ecb_sink = SinkFactory(arch).ecb(subsink);
// const auto cfb_sink = SinkFactory(arch).cfb(subsink, iv);
//
// НО тогда вопрос - как будет устроен SinkFactory?
// ecb(ss)
// {
// 	return arch->??? я не хочу здесь писать ecb... Я хочу, чтобы в arch было меньше методов.
// 	return arch->sink(ss, ECBAlg());
// }
//
// Но это не сработает, если мы в EcbAlg не передадим фабрику алгоритмов данной архитектуры.
//
// Связать ключ с алгоритмом может только архитектурный класс. Который знает тип ключа (который разный в зависимости от архитектуры).
// При этом мы не хотим распространять знание об архитектурах на другие классы. (Знание об алгоритмах можем).
//
//
// может быть arch->cfb(iv)->sink(subsink)
//
// Будет 6 методов в arch, на каждый из них - будет арчезависимый класс (у него внутри будет ключ но не стрим).
// Который внутри сделает Sink/Source.
// Но интерфейсы вполне переносимы. И это можно будет завернуть.
// Но завернуть - это отдельные классы, какие-то фабрики по типам.
// Может быть те самые алгоритмы?
//
// CFBAlg(arch, iv).sink(subsink);

class Arch {
	virtual shared_ptr<const IOFactory> ecb() const = 0;
	virtual shared_ptr<const IOFactory> cfb(??? iv) const = 0;
	virtual shared_ptr<const IOFactory> imit() const = 0;
};

class IOFactory {
	virtual shared_ptr<const Sink> sink(subsink) const = 0;
	virtual shared_ptr<const Source> source(subsource) const = 0;
}

// Ключи тоже стоит обдумать.
// Ключи хранятся в разных исходных форматах.
// Назовем это контейнер.
// 
// Но должны быть сконвертированы в ключ, подходящий для конкретной архитектуры.
// Контейнер ничего не знает про архитектуру и не может непосредственно вернуть готовый для нее ключ.
// Вернуть данные ключа он тоже не может - это несекурно.
//
// Как тут обойтись без приведения типов?
// Мы могли бы передать некоторую фабрику в ключ, чтобы тот с помощью нее сделать новый класс.
// Но интерфейс этого класса будет меняться в зависимости от архитектуры.
// Либо разработать интерфейс, который подойдет всем... С переменным количеством блоков.
//
// class Key {
// 	size_t size() const;
// 	vector<uint64_t> transform(const vector<uint64_t> &in) const;
// }
//
// В такой интерфейс можно впихнуть любую архитектуру, сколько бы блоков она не обрабатывала в паралель...
// Но мы имеем возможно задержку на аллокации в векторе.
//
// Передавать всегда максимальный размер? Недальновидно. Завтра он станет еще максимальнее.
// Вообще вектор - это не обязательно какие-то накладные расходы - он вполне может быть выделен заранее.
// Может быть memory_view?
//
// span кстати тоже не пойдет... размер требуется знать заранее.
//
// Легковесные обертки вообще имеют недостаток, который выражается в том, что они не владеют теми данными, которые попадают к ним на вход.
// Для методов это не очень страшно (если метод константный). А вот для конструкторов пожалуй не очень приемлимо.
// Но я уже сильно задумался об оптимизации - это вредно.
